From 064b2e905fc3bea75d42dfdf43b27d9ae76eb2f3 Mon Sep 17 00:00:00 2001
From: dean <dean@trapezium.(none)>
Date: Wed, 24 Apr 2013 16:01:42 -0400
Subject: [PATCH] revise of hologic instrument

---
 .../instrument/holologic/APEXInstrumentRunner.java |  382 +++++++------
 .../holologic/APEXScanDataExtractor.java           |  602 ++++++++++++++++----
 .../holologic/APSpineScanDataExtractor.java        |   15 +-
 .../holologic/ForearmScanDataExtractor.java        |   15 +-
 .../instrument/holologic/HipScanDataExtractor.java |   15 +-
 .../holologic/IVAImagingScanDataExtractor.java     |   28 +-
 .../holologic/WholeBodyScanDataExtractor.java      |   15 +-
 .../resources/META-INF/onyx/defaults.properties    |   14 +-
 .../META-INF/spring/instrument-context.xml         |   20 +-
 9 files changed, 812 insertions(+), 294 deletions(-)

diff --git a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APEXInstrumentRunner.java b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APEXInstrumentRunner.java
index 5824a1b..4e62f5a 100644
--- a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APEXInstrumentRunner.java
+++ b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APEXInstrumentRunner.java
@@ -28,6 +28,7 @@ import org.obiba.onyx.jade.instrument.service.InstrumentExecutionService;
 import org.obiba.onyx.util.data.Data;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.springframework.dao.DataAccessException;
 import org.springframework.jdbc.core.JdbcTemplate;
 import org.springframework.util.FileSystemUtils;
 
@@ -39,7 +40,7 @@ public class APEXInstrumentRunner implements InstrumentRunner {
 
   private JdbcTemplate patScanDb;
 
-  private File scanDataDir;
+  private JdbcTemplate refCurveDb;
 
   private DicomSettings dicomSettings;
 
@@ -47,7 +48,7 @@ public class APEXInstrumentRunner implements InstrumentRunner {
 
   private File dcmDir;
 
-  private List<String> participantFiles = new ArrayList<String>();
+  //private List<String> participantFiles = new ArrayList<String>();
 
   private Set<String> outVendorNames;
 
@@ -57,131 +58,19 @@ public class APEXInstrumentRunner implements InstrumentRunner {
 
   private ApexReceiver apexReceiver = new ApexReceiver();
 
-  private String participantKey;
-
   private String participantID;
 
-  private boolean isRepeatable;
-
-  private List<Map<String, Data>> retrieveDeviceData() {
-
-    List<Map<String, Data>> dataList = new ArrayList<Map<String, Data>>();
-
-    log.info("participantId: " + participantID);
-    participantKey = patScanDb
-        .queryForObject("select p.PATIENT_KEY from PATIENT p where p.IDENTIFIER1=?", String.class, participantID);
-    log.info("participantKey: " + participantKey);
-    if(instrumentExecutionService.hasInputParameter("HipSide")) {
-      String hipSide = instrumentExecutionService.getInputParameterValue("HipSide").getValue();
-      log.info("hipSide: " + hipSide);
-      log.info("expected: " + instrumentExecutionService.getExpectedMeasureCount());
-      if(hipSide != null) {
-        if(hipSide.toUpperCase().startsWith("L")) {
-          extractLeftHip(dataList);
-        } else if(hipSide.toUpperCase().startsWith("R")) {
-          extractRightHip(dataList);
-        } else if(hipSide.toUpperCase().startsWith("B")) {
-          if(instrumentExecutionService.getExpectedMeasureCount() > 1) {
-            extractLeftHip(dataList);
-            extractRightHip(dataList);
-          } else {
-            extractScanData(dataList,
-                new HipScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.LEFT, server, apexReceiver));
-            extractScanData(dataList,
-                new HipScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.RIGHT, server, apexReceiver));
-          }
-        }
-      }
-    } else if(instrumentExecutionService.getExpectedMeasureCount() > 1) {
-      extractLeftHip(dataList);
-      extractRightHip(dataList);
-    } else {
-      extractScanData(dataList,
-          new HipScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.LEFT, server, apexReceiver));
-      extractScanData(dataList,
-          new HipScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.RIGHT, server, apexReceiver));
-    }
-    if(instrumentExecutionService.hasInputParameter("ForearmSide")) {
-      String forearmSide = instrumentExecutionService.getInputParameterValue("ForearmSide").getValue();
-      if(forearmSide != null) {
-        if(forearmSide.toUpperCase().startsWith("L")) {
-          extractScanData(dataList,
-              new ForearmScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.LEFT, server, apexReceiver) {
-                @Override
-                public String getName() {
-                  return "FA";
-                }
-              });
-        } else if(forearmSide.toUpperCase().startsWith("R")) {
-          extractScanData(dataList,
-              new ForearmScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.RIGHT, server, apexReceiver) {
-                @Override
-                public String getName() {
-                  return "FA";
-                }
-              });
-        }
-      }
-    } else {
-      extractScanData(dataList,
-          new ForearmScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.LEFT, server, apexReceiver));
-      extractScanData(dataList,
-          new ForearmScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.RIGHT, server, apexReceiver));
-    }
-    extractScanData(dataList,
-        new WholeBodyScanDataExtractor(patScanDb, scanDataDir, participantKey, server, apexReceiver));
-    extractScanData(dataList,
-        new IVAImagingScanDataExtractor(patScanDb, scanDataDir, participantKey, Energy.CLSA_DXA, server, apexReceiver));
-
-    return dataList;
-
-  }
-
-  private void extractRightHip(List<Map<String, Data>> dataList) {
-    extractScanData(dataList,
-        new HipScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.RIGHT, server, apexReceiver) {
-          @Override
-          public String getName() {
-            return "HIP";
-          }
-        });
-  }
-
-  private void extractLeftHip(List<Map<String, Data>> dataList) {
-    extractScanData(dataList,
-        new HipScanDataExtractor(patScanDb, scanDataDir, participantKey, Side.LEFT, server, apexReceiver) {
-          @Override
-          public String getName() {
-            return "HIP";
-          }
-        });
-  }
-
-  private void extractScanData(List<Map<String, Data>> dataList, APEXScanDataExtractor extractor) {
-    log.info("extractScanData");
-    // filter the values to output
-    Map<String, Data> extractedData = extractor.extractData();
-    Map<String, Data> outputData = new HashMap<String, Data>();
-
-    for(Entry<String, Data> entry : extractedData.entrySet()) {
-      if(outVendorNames.contains(entry.getKey())) {
-        outputData.put(entry.getKey(), entry.getValue());
-      }
-    }
-    log.info(extractedData + "");
-    log.info(outputData + "");
-    dataList.add(outputData);
+  private Map<String, String> participantData = new HashMap<String, String>();
 
-    participantFiles.addAll(extractor.getFileNames());
-  }
+  private boolean isRepeatable;
 
-  public void sendDataToServer(Map<String, Data> data) {
-    instrumentExecutionService.addOutputParameterValues(data);
+  public enum Side {
+    LEFT, RIGHT
   }
 
   /**
-   * Implements parent method initialize from InstrumentRunner Delete results from previous measurement and initiate the
-   * input file to be read by the external application
+   * Implements initialize() of parent InstrumentRunner. Delete results from previous measurement and initiate the input
+   * file to be read by the external application.
    */
   public void initialize() {
     participantID = instrumentExecutionService.getParticipantID();
@@ -194,16 +83,16 @@ public class APEXInstrumentRunner implements InstrumentRunner {
       if(tmpDir.delete() == false || tmpDir.mkdir() == false) {
         throw new RuntimeException("Cannot create temp directory");
       }
-      this.dcmDir = tmpDir;
+      dcmDir = tmpDir;
       log.info("DICOM files stored to {}", dcmDir.getAbsolutePath());
     } catch(IOException e) {
       throw new RuntimeException(e);
     }
-    this.server = new DicomServer(dcmDir, dicomSettings);
+    server = new DicomServer(dcmDir, dicomSettings);
   }
 
   /**
-   * Implements parent method run from InstrumentRunner Launch the external application, retrieve and send the data
+   * Implements run() of parent InstrumentRunner. Launch the external application, retrieve and send the data.
    */
   public void run() {
     log.info("Start Dicom server");
@@ -215,18 +104,62 @@ public class APEXInstrumentRunner implements InstrumentRunner {
     apexReceiver.waitForExit();
   }
 
+  /**
+   * Implements shutdown() of parent InstrumentRunner. Closes dicom communication channel, deletes temporary dcm files
+   * transferred by DICOM transfer from Apex sender to dcm4che receiver.
+   */
+  public void shutdown() {
+    log.info("Shutdown Dicom server");
+    server.stop();
+    deleteTemporaryDicomFiles();
+  }
+
+  /**
+   * Called by initialize(). Initialize and display the GUI for capturing the dcm files from Apex.
+   */
+  public void initApexReceiverStatus() {
+    apexReceiver.setParticipantId(participantID);
+    apexReceiver.setCheckActionListener(new ActionListener() {
+      public void actionPerformed(ActionEvent e) {
+        retrieveMeasurements();
+        if(isCompleteVariable()) {
+          if(isRepeatable) {
+            apexReceiver.setVariableStatusOKButCheck();
+          } else {
+            apexReceiver.setVariableStatusOK();
+          }
+          if(apexReceiver.isCompleteRawInDicom()) {
+            apexReceiver.setDicomStatusOK();
+            apexReceiver.setSaveEnable();
+          } else {
+            apexReceiver.setDicomStatusNotOK();
+          }
+        } else {
+          apexReceiver.setVariableStatusNotOK();
+          apexReceiver.setDicomStatusNotReady();
+        }
+        apexReceiver.validate();
+        apexReceiver.repaint();
+      }
+    });
+    apexReceiver.setVisible(true);
+  }
+
+  /**
+   * Called by initApexReceiverStatus(). Retrieve the device data, add to list of variables to send, send to
+   * instrumentExecutionService.
+   */
   private void retrieveMeasurements() {
     log.info("Retrieving measurements");
     List<Map<String, Data>> dataList = retrieveDeviceData();
-
     log.info("Sending data to server");
     sentVariables.clear();
     for(Map<String, Data> dataMap : dataList) {
       for(Map.Entry<String, Data> entry : dataMap.entrySet()) {
         sentVariables.add(entry.getKey());
       }
-      // send only if measure is complete (all variable assigned)
-      // because repeatable measure accept partial variable set
+      // send only if the measure is complete (all variables assigned)
+      // because repeatable measures accept partial variable sets
       if(isRepeatable) {
         if(outVendorNames.equals(dataMap.keySet())) {
           sendDataToServer(dataMap);
@@ -237,15 +170,9 @@ public class APEXInstrumentRunner implements InstrumentRunner {
     }
   }
 
-  public void shutdown() {
-    log.info("Shutdown Dicom server");
-    server.stop();
-    deleteTemporaryDicomFiles();
-  }
-
   /**
-   * Return true if you sent all required variable, false otherwise
-   *
+   * Called by initApexReceiverStatus(). Return true if all required variables were sent, false otherwise.
+   * 
    * @return
    */
   private boolean isCompleteVariable() {
@@ -253,7 +180,7 @@ public class APEXInstrumentRunner implements InstrumentRunner {
     List<String> sentVariablesCopy = new ArrayList<String>(sentVariables);
     boolean retValue = true;
 
-    // if repeatable measure check if all variables in measure has been sent
+    // if this is a repeatable measure, check if all variables in the measure have been sent
     for(int i = 0; i < instrumentExecutionService.getExpectedMeasureCount(); i++) {
       for(String out : outVendorNames) {
         if(sentVariablesCopy.contains(out) == false) {
@@ -268,43 +195,170 @@ public class APEXInstrumentRunner implements InstrumentRunner {
     return retValue;
   }
 
-  private void deleteTemporaryDicomFiles() {
-    log.info("Delete temporary dicom files");
-    FileSystemUtils.deleteRecursively(dcmDir);
-  }
+  /**
+   * Called by retrieveMeasurements(). Queries Apex PatScanDb for patient key, DOB, gender based on participant visit
+   * ID. Extracts Hip, Forearm, Whole Body and Spine scans and analysis data.
+   */
+  private List<Map<String, Data>> retrieveDeviceData() {
 
-  public void initApexReceiverStatus() {
-    apexReceiver.setParticipantId(participantID);
-    apexReceiver.setCheckActionListener(new ActionListener() {
-      public void actionPerformed(ActionEvent e) {
-        retrieveMeasurements();
-        if(isCompleteVariable()) {
-          if(isRepeatable) {
-            apexReceiver.setVariableStatusOKButCheck();
-          } else {
-            apexReceiver.setVariableStatusOK();
-          }
-          if(apexReceiver.isCompleteRawInDicom()) {
-            apexReceiver.setDicomStatusOK();
-            apexReceiver.setSaveEnable();
+    List<Map<String, Data>> dataList = new ArrayList<Map<String, Data>>();
+
+    log.info("participantId: " + participantID);
+
+    participantData.clear();
+
+    String sql = "SELECT PATIENT_KEY, BIRTHDATE, SEX FROM PATIENT WHERE IDENTIFIER1 = ?";
+    try {
+      Map<String, Object> results = patScanDb.queryForMap(sql, new Object[] { participantID });
+      if(results != null) {
+        participantData.put("participantKey", results.get("PATIENT_KEY").toString());
+        participantData.put("participantDOB", results.get("BIRTHDATE").toString());
+        participantData.put("participantGender", results.get("SEX").toString());
+      }
+    } catch(DataAccessException e) {
+      throw e;
+    }
+
+    log.info("hip block in runner start");
+    if(instrumentExecutionService.hasInputParameter("HipSide")) {
+      String hipSide = instrumentExecutionService.getInputParameterValue("HipSide").getValue();
+      log.info("hipSide: " + hipSide);
+      log.info("expected: " + instrumentExecutionService.getExpectedMeasureCount());
+      if(hipSide != null) {
+        if(hipSide.toUpperCase().startsWith("L")) {
+          extractLeftHip(dataList);
+        } else if(hipSide.toUpperCase().startsWith("R")) {
+          extractRightHip(dataList);
+        } else if(hipSide.toUpperCase().startsWith("B")) {
+          if(instrumentExecutionService.getExpectedMeasureCount() > 1) {
+            extractLeftHip(dataList);
+            extractRightHip(dataList);
           } else {
-            apexReceiver.setDicomStatusNotOK();
+            extractScanData(dataList, new HipScanDataExtractor(patScanDb, refCurveDb, participantData, Side.LEFT, server, apexReceiver));
+            extractScanData(dataList, new HipScanDataExtractor(patScanDb, refCurveDb, participantData, Side.RIGHT, server, apexReceiver));
           }
-        } else {
-          apexReceiver.setVariableStatusNotOK();
-          apexReceiver.setDicomStatusNotReady();
         }
-        apexReceiver.validate();
-        apexReceiver.repaint();
+      }
+    } else if(instrumentExecutionService.getExpectedMeasureCount() > 1) {
+      extractLeftHip(dataList);
+      extractRightHip(dataList);
+    } else {
+      extractScanData(dataList, new HipScanDataExtractor(patScanDb, refCurveDb, participantData, Side.LEFT, server, apexReceiver));
+      extractScanData(dataList, new HipScanDataExtractor(patScanDb, refCurveDb, participantData, Side.RIGHT, server, apexReceiver));
+    }
+    log.info("hip block in runner end");
+
+    log.info("forearm block in runner start");
+    if(instrumentExecutionService.hasInputParameter("ForearmSide")) {
+      String forearmSide = instrumentExecutionService.getInputParameterValue("ForearmSide").getValue();
+      if(forearmSide != null) {
+        if(forearmSide.toUpperCase().startsWith("L")) {
+          extractScanData(dataList, new ForearmScanDataExtractor(patScanDb, refCurveDb, participantData, Side.LEFT, server, apexReceiver) {
+            @Override
+            public String getName() {
+              return "FA";
+            }
+          });
+        } else if(forearmSide.toUpperCase().startsWith("R")) {
+          extractScanData(dataList, new ForearmScanDataExtractor(patScanDb, refCurveDb, participantData, Side.RIGHT, server, apexReceiver) {
+            @Override
+            public String getName() {
+              return "FA";
+            }
+          });
+        }
+      }
+    } else {
+      extractScanData(dataList, new ForearmScanDataExtractor(patScanDb, refCurveDb, participantData, Side.LEFT, server, apexReceiver));
+      extractScanData(dataList, new ForearmScanDataExtractor(patScanDb, refCurveDb, participantData, Side.RIGHT, server, apexReceiver));
+    }
+    log.info("forearm block in runner end");
+
+    log.info("wbody block in runner start");
+    extractScanData(dataList, new WholeBodyScanDataExtractor(patScanDb, refCurveDb, participantData, server, apexReceiver));
+    log.info("wbody block in runner end");
+
+    log.info("spine block in runner start");
+    extractScanData(dataList, new IVAImagingScanDataExtractor(patScanDb, refCurveDb, participantData, Energy.CLSA_DXA, server, apexReceiver));
+    log.info("spine block in runner end");
+
+    return dataList;
+  }
+
+  /**
+   * Called by retrieveMeasurements().
+   * 
+   * @param data
+   */
+  public void sendDataToServer(Map<String, Data> data) {
+    instrumentExecutionService.addOutputParameterValues(data);
+  }
+
+  /**
+   * Called by retrieveDeviceData(). Generic calling interface to extract Apex data. Passes abstract data extractor:
+   * child classes unique to scan type (ie., forearm, spine etc.).
+   * 
+   * @param dataList
+   * @param extractor
+   */
+  private void extractScanData(List<Map<String, Data>> dataList, APEXScanDataExtractor extractor) {
+    log.info("extractScanData");
+    // filter the values to output
+    Map<String, Data> extractedData = extractor.extractData();
+    Map<String, Data> outputData = new HashMap<String, Data>();
+
+    for(Entry<String, Data> entry : extractedData.entrySet()) {
+      if(outVendorNames.contains(entry.getKey())) {
+        outputData.put(entry.getKey(), entry.getValue());
+      }
+    }
+    log.info(extractedData + "");
+    log.info(outputData + "");
+    dataList.add(outputData);
+
+    // participantFiles.addAll(extractor.getFileNames());
+  }
+
+  /**
+   * Called by retrieveDeviceData(). Calling interface to extract Apex right hip data.
+   * 
+   * @param dataList
+   */
+  private void extractRightHip(List<Map<String, Data>> dataList) {
+    extractScanData(dataList, new HipScanDataExtractor(patScanDb, refCurveDb, participantData, Side.RIGHT, server, apexReceiver) {
+      @Override
+      public String getName() {
+        return "HIP";
       }
     });
-    apexReceiver.setVisible(true);
   }
 
-  public enum Side {
-    LEFT, RIGHT
+  /**
+   * Called by retrieveDeviceData(). Calling interface to extract Apex left hip data.
+   * 
+   * @param dataList
+   */
+  private void extractLeftHip(List<Map<String, Data>> dataList) {
+    extractScanData(dataList, new HipScanDataExtractor(patScanDb, refCurveDb, participantData, Side.LEFT, server, apexReceiver) {
+      @Override
+      public String getName() {
+        return "HIP";
+      }
+    });
+  }
+
+  /**
+   * Called by shutdown(). Deletes all temporary dcm files transferred from Apex to client.
+   */
+  private void deleteTemporaryDicomFiles() {
+    log.info("Delete temporary dicom files");
+    FileSystemUtils.deleteRecursively(dcmDir);
   }
 
+  //
+  // Set/Get methods.
+  //
+
   public void setInstrumentExecutionService(InstrumentExecutionService instrumentExecutionService) {
     this.instrumentExecutionService = instrumentExecutionService;
   }
@@ -313,6 +367,10 @@ public class APEXInstrumentRunner implements InstrumentRunner {
     this.patScanDb = patScanDb;
   }
 
+  public void setRefCurveDb(JdbcTemplate refCurveDb) {
+    this.refCurveDb = refCurveDb;
+  }
+
   public void setDicomSettings(DicomSettings dicomSettings) {
     this.dicomSettings = dicomSettings;
   }
diff --git a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APEXScanDataExtractor.java b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APEXScanDataExtractor.java
index e4c6a3e..5dbbf26 100644
--- a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APEXScanDataExtractor.java
+++ b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APEXScanDataExtractor.java
@@ -9,12 +9,16 @@
  ******************************************************************************/
 package org.obiba.onyx.jade.instrument.holologic;
 
-import java.io.File;
 import java.io.IOException;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.text.DecimalFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -36,176 +40,439 @@ import org.springframework.jdbc.core.ResultSetExtractor;
 
 public abstract class APEXScanDataExtractor {
 
+  /**
+   * Static ivar needed for computing T- and Z-scores. Map distinct BMD variable name(s) (eg., HTOT_BMD) for a given
+   * PatScanDb table (eg., Hip) and the corresponding bonerange code in the RefScanDb ReferenceCurve table (eg., 123.).
+   * Additional BMD variables and codes should be added here for other tables (ie., Spine).
+   */
+  protected static final Map<String, String> ranges = new HashMap<String, String>();
+  static {
+    // forearm
+    ranges.put("RU13TOT_BMD", "1..");
+    ranges.put("RUMIDTOT_BMD", ".2.");
+    ranges.put("RUUDTOT_BMD", "..3");
+    ranges.put("RUTOT_BMD", "123");
+    ranges.put("R_13_BMD", "R..");
+    ranges.put("R_MID_BMD", ".R.");
+    ranges.put("R_UD_BMD", "..R");
+    ranges.put("RTOT_BMD", "RRR");
+    ranges.put("U_13_BMD", "U..");
+    ranges.put("U_MID_BMD", ".U.");
+    ranges.put("U_UD_BMD", "..U");
+    ranges.put("UTOT_BMD", "UUU");
+
+    // whole body
+    ranges.put("WBTOT_BMD", "NULL");
+
+    // hip
+    ranges.put("NECK_BMD", "1...");
+    ranges.put("TROCH_BMD", ".2..");
+    ranges.put("INTER_BMD", "..3.");
+    ranges.put("WARDS_BMD", "...4");
+    ranges.put("HTOT_BMD", "123.");
+  }
+
   private static final Logger log = LoggerFactory.getLogger(APEXScanDataExtractor.class);
 
   private JdbcTemplate patScanDb;
 
-  private File scanDataDir;
-
-  private String participantKey;
+  private JdbcTemplate refCurveDb;
 
   private String scanID;
 
-  private String scanMode;
-
-  private String pFileName;
+  private String scanDate;
 
-  private String rFileName;
+  private String scanMode;
 
-  private List<String> fileNames;
+  /*
+   * private String pFileName;
+   * 
+   * private String rFileName;
+   * 
+   * private List<String> fileNames;
+   */
+  private Map<String, String> participantData;
 
   private DicomServer server;
 
   private ApexReceiver apexReceiver;
 
-  protected APEXScanDataExtractor(JdbcTemplate patScanDb, File scanDataDir, String participantKey, DicomServer server, ApexReceiver apexReceiver) {
+  //
+  // Abstract get methods.
+  //
+
+  public abstract String getName();
+
+  public abstract String getDicomBodyPartName();
+
+  public abstract Side getSide();
+
+  protected abstract long getScanType();
+
+  public abstract String getRefType();
+
+  public abstract String getRefSource();
+
+  /**
+   * Constructor.
+   */
+  protected APEXScanDataExtractor(JdbcTemplate patScanDb, JdbcTemplate refCurveDb, Map<String, String> participantData, DicomServer server, ApexReceiver apexReceiver) {
     super();
     this.patScanDb = patScanDb;
-    this.scanDataDir = scanDataDir;
-    this.participantKey = participantKey;
+    this.refCurveDb = refCurveDb;
+    this.participantData = participantData;
     this.server = server;
     this.apexReceiver = apexReceiver;
   }
 
+  /**
+   * Called by APEXInstrumentRunner extractScanData(). Get scan information from Apex PatScan db, get the data values,
+   * compute T- and Z-scores for BMD values.
+   */
   public Map<String, Data> extractData() {
+
+    /** get the dicom file(s) for a given type of scan */
     Map<String, Data> data = extractScanAnalysisData();
-    if(scanID != null) {
+
+    log.info("start data with " + Integer.toString(data.size()) + " entries");
+
+    /** get the variables associated with an analysis of the scan */
+
+    if(!data.isEmpty()) {
+      log.info("getting data from concrete impl of extractDataImp");
       extractDataImpl(data);
+      log.info("getting TZscores... ");
+      computeTZScore(data);
     }
 
+    log.info("returning data with " + Integer.toString(data.size()) + " entries");
     return data;
   }
 
-  protected String getPFileName() {
-    return pFileName;
+  /**
+   * Called by extractData(). Query the Apex PatScan db for the scan ID, raw data file name, scan mode and scan type
+   * based on the patient key and scan type. Scan type is provided by child classes (eg., AP Spine = 1).
+   */
+  private Map<String, Data> extractScanAnalysisData() {
+    log.info("extractscananalysisdata: " + getParticipantKey() + ", " + Long.toString(getScanType()));
+    return patScanDb.query("select SCANID, SCAN_MODE, SCAN_DATE from ScanAnalysis where PATIENT_KEY = ? and SCAN_TYPE = ?", new PreparedStatementSetter() {
+      public void setValues(PreparedStatement ps) throws SQLException {
+        ps.setString(1, getParticipantKey());
+        ps.setString(2, Long.toString(getScanType()));
+      }
+    }, new ScanAnalysisResultSetExtractor());
   }
 
-  protected String getRFileName() {
-    return rFileName;
-  }
+  /**
+   * Called by extractData().
+   * 
+   * @param data
+   */
+  protected abstract void extractDataImpl(Map<String, Data> data);
 
-  public abstract String getName();
+  /**
+   * Called by extractData(). Computes T- and Z-score and adds to data collection.
+   * 
+   * @param data
+   */
+  protected void computeTZScore(Map<String, Data> data) throws DataAccessException, IllegalArgumentException {
 
-  public abstract String getDicomBodyPartName();
+    if(data == null || data.isEmpty()) return;
 
-  public abstract Side getSide();
+    String prefix = getResultPrefix() + "_";
 
-  protected abstract long getScanType();
+    Map<String, Double> bmdData = new HashMap<String, Double>();
+    for(Map.Entry<String, Data> entry : data.entrySet()) {
+      String key = entry.getKey();
+      if(key.endsWith("_BMD")) {
+        log.info("key pre: " + key + ", new key: " + key.replace(prefix, ""));
+        key = key.replace(prefix, "");
+        if(ranges.containsKey(key)) {
+          bmdData.put(key, (Double) entry.getValue().getValue());
+          log.info("ranges contains key: " + key);
+        }
+      }
+    }
 
-  protected abstract void extractDataImpl(Map<String, Data> data);
+    log.info(prefix + " data contains: " + Integer.toString(data.size()) + " possible entries to get bmd values from");
+    log.info(prefix + " bmddata contains: " + Integer.toString(bmdData.size()) + " entries to get tz");
+
+    for(Map.Entry<String, Double> entry : bmdData.entrySet()) {
+      String bmdBoneRangeKey = entry.getKey();
+      Double bmdValue = entry.getValue();
+
+      log.info("working on range key:" + bmdBoneRangeKey + " with value: " + bmdValue.toString());
+
+      // T- and Z-scores are interpolated from X, Y reference curve data.
+      // A curve depends on the type of scan, gender, ethnicity, and
+      // the coded anatomic region that bmd was measured in.
+      // Determine the unique curve ID along with the age at which
+      // peak bmd occurs. Implementation assumes ethnicity is always Caucasian
+      // and gender is always female in accordance with WHO and
+      // Osteoporosis Canada guidelines.
+      //
+      String sql = "SELECT UNIQUE_ID, AGE_YOUNG FROM ReferenceCurve";
+      sql += " WHERE REFTYPE = '" + getRefType() + "'";
+      sql += " AND IF_CURRENT = 1 AND SEX = 'F' AND ETHNIC IS NULL AND METHOD IS NULL";
+      sql += " AND SOURCE LIKE '%" + getRefSource() + "%'";
+      sql += " AND BONERANGE ";
+      sql += (ranges.get(bmdBoneRangeKey).equals("NULL") ? ("IS NULL") : ("= '" + ranges.get(bmdBoneRangeKey) + "'"));
+
+      log.info("first query: " + sql);
+      Map<String, Object> mapResult;
+      try {
+        mapResult = refCurveDb.queryForMap(sql);
+      } catch(DataAccessException e) {
+        throw e;
+      }
+      String curveId = mapResult.get("UNIQUE_ID").toString();
+      Double ageYoung = new Double(mapResult.get("AGE_YOUNG").toString());
 
-  protected JdbcTemplate getPatScanDb() {
-    return patScanDb;
-  }
+      // Determine the age values (X axis variable) of the curve
+      //
+      List<Double> ageTable = new ArrayList<Double>();
+      sql = "SELECT X_VALUE FROM Points WHERE UNIQUE_ID = " + curveId;
 
-  protected String getParticipantKey() {
-    return participantKey;
-  }
+      log.info("second query: " + sql);
 
-  private Map<String, Data> extractScanAnalysisData() {
-    return patScanDb.query("select SCANID, PFILE_NAME, SCAN_MODE, SCAN_TYPE from ScanAnalysis where PATIENT_KEY = ? and SCAN_TYPE = ?", new PreparedStatementSetter() {
-      public void setValues(PreparedStatement ps) throws SQLException {
-        ps.setString(1, getParticipantKey());
-        ps.setString(2, Long.toString(getScanType()));
+      List<Map<String, Object>> listResult;
+      try {
+        listResult = refCurveDb.queryForList(sql);
+      } catch(DataAccessException e) {
+        throw e;
+      }
+      for(Map<String, Object> row : listResult) {
+        ageTable.add(new Double(row.get("X_VALUE").toString()));
       }
-    }, new ScanAnalysisResultSetExtractor());
-  }
 
-  protected String getResultPrefix() {
-    return getName();
-  }
+      // Determine the discrete age values that bracket the
+      // participant's age (at the time of the scan).
+      //
+      Double age = null;
+      try {
+        age = computeYearsDifference(getScanDate(), getParticipantDOB());
+      } catch(ParseException e) {
+      }
 
-  protected String getScanID() {
-    return scanID;
-  }
+      ageBracket bracket = new ageBracket();
+      bracket.compute(age, ageTable);
+
+      // Determine the bmd, skewness factor and standard deviation
+      // at the bracketing and peak bmd age values.
+      //
+      List<Double> bmdValues = new ArrayList<Double>();
+
+      sql = "SELECT Y_VALUE, L_VALUE, STD FROM Points WHERE UNIQUE_ID = " + curveId;
+      sql += " AND X_VALUE = ";
+
+      Double[] x_value_array = { bracket.ageMin, bracket.ageMax, ageYoung };
+      for(int i = 0; i < x_value_array.length; i++) {
+        mapResult.clear();
+        log.info("third query iter " + ((Integer) i).toString() + " : " + sql + x_value_array[i].toString());
+
+        try {
+          mapResult = refCurveDb.queryForMap(sql + x_value_array[i].toString());
+        } catch(DataAccessException e) {
+          throw e;
+        }
+
+        bmdValues.add(new Double(mapResult.get("Y_VALUE").toString()));
+        bmdValues.add(new Double(mapResult.get("L_VALUE").toString()));
+        bmdValues.add(new Double(mapResult.get("STD").toString()));
+      }
+
+      Double u = 0.;
+      if(age != bracket.ageMin) u = (age - bracket.ageMin) / bracket.ageSpan;
+
+      List<Double> interpValues = new ArrayList<Double>();
+      for(int i = 0; i < bmdValues.size() / 3; i++)
+        interpValues.add((1. - u) * bmdValues.get(i) + u * bmdValues.get(i + 3));
+
+      Double M_value = interpValues.get(0);
+      Double L_value = interpValues.get(1);
+      Double sigma = interpValues.get(2);
+      Double X_value = bmdValue;
+      Double Z_score = M_value * (Math.pow(X_value / M_value, L_value) - 1.) / (L_value * sigma);
+      DecimalFormat df = new DecimalFormat("#.0");
+      Z_score = Double.valueOf(df.format(Z_score));
+      if(Math.abs(Z_score) == 0.) Z_score = 0.;
+
+      M_value = bmdValues.get(6);
+      L_value = bmdValues.get(7);
+      sigma = bmdValues.get(8);
+
+      Double T_score = M_value * (Math.pow(X_value / M_value, L_value) - 1.) / (L_value * sigma);
+      T_score = Double.valueOf(df.format(T_score));
+      if(Math.abs(T_score) == 0.) T_score = 0.;
+
+      String varName = getResultPrefix() + "_" + bmdBoneRangeKey.replace("_BMD", "_T");
+      if(data.keySet().contains(varName)) {
+        throw new IllegalArgumentException("Instrument variable name already defined: " + varName);
+      }
+      data.put(varName, DataBuilder.buildDecimal(T_score));
+
+      varName = getResultPrefix() + "_" + bmdBoneRangeKey.replace("_BMD", "_Z");
+      if(data.keySet().contains(varName)) {
+        throw new IllegalArgumentException("Instrument variable name already defined: " + varName);
+      }
+      data.put(varName, DataBuilder.buildDecimal(Z_score));
 
-  public List<String> getFileNames() {
-    return fileNames != null ? fileNames : (fileNames = new ArrayList<String>());
+      log.info("finished current key: " + bmdBoneRangeKey);
+    }
   }
 
+  /**
+   * Called by extractScanAnalysisData(). Implementation of ResultSetExtractor. Process the query that recovers raw DEXA
+   * scan P & R data file names and dicom files from Apex receiver. P and R data files are embedded in dicom files.
+   * Note: the Enterprise Data Management install option must be activated in Apex with a license key for the dicom
+   * export of embedded P and R data.
+   */
   private final class ScanAnalysisResultSetExtractor implements ResultSetExtractor<Map<String, Data>> {
     @Override
     public Map<String, Data> extractData(ResultSet rs) throws SQLException, DataAccessException {
       Map<String, Data> data = new HashMap<String, Data>();
 
-      // assume the last scan of a given type is the one we are interested in
-      // + stores all scan files for future deletion
+      log.info("starting result set processing");
+
       while(rs.next()) {
         scanID = rs.getString("SCANID");
         scanMode = rs.getString("SCAN_MODE");
         log.info("Visiting scan: " + scanID);
-        pFileName = rs.getString("PFILE_NAME");
+        scanDate = rs.getString("SCAN_DATE");
+      }
 
-        if(pFileName != null) {
-          rFileName = pFileName.replace(".P", ".R");
-          getFileNames().add(pFileName);
-          getFileNames().add(rFileName);
-        } else {
-          rFileName = null;
+      if(scanID != null && scanMode != null) {
+
+        List<StoredDicomFile> selectList = new ArrayList<StoredDicomFile>();
+        List<StoredDicomFile> listDicomFiles = server.listSortedDicomFiles();
+
+        // there must be at least one dicom file with a body part examined key
+        // body part name depends on the data extractor class
+        // LSPINE = spine, expects 3 files
+        // null = whole body, expects 2 files
+        // HIP = hip, expects 1 to 2 files
+        // ARM = forearm, expects 1 to 2 files
+        //
+        String bodyPartName = getDicomBodyPartName();
+        // String laterality = getSide().toString();
+        // boolean completeSet = false;
+
+        for(StoredDicomFile sdf : listDicomFiles) {
+          try {
+            DicomObject dicomObject = sdf.getDicomObject();
+            boolean dcmBodyPartKey = dicomObject.contains(Tag.BodyPartExamined);
+            String dcmBodyPart = dicomObject.getString(Tag.BodyPartExamined);
+            String dcmSide = dicomObject.getString(Tag.Laterality);
+
+            if(bodyPartName == "LSPINE") {
+              if(dcmBodyPartKey) {
+                if(bodyPartName.equals(dcmBodyPart)) selectList.add(sdf);
+              } else {
+                selectList.add(sdf);
+              }
+            } else if(bodyPartName == "ARM") {
+              if(dcmBodyPartKey) {
+                if(bodyPartName.equals(dcmBodyPart) && dcmSide != null) selectList.add(sdf);
+              }
+            } else if(bodyPartName == "HIP") {
+              if(dcmBodyPartKey) {
+                if(bodyPartName.equals(dcmBodyPart) && dcmSide != null) selectList.add(sdf);
+              }
+            } else {
+              if(dcmBodyPartKey && dcmSide == null) {
+                selectList.add(sdf);
+              }
+            }
+
+            // if there is a body part examined but it is not equal to the expected bodypart name
+
+            // log.info("contains body part key: " + (containsBodyPartKey ? "true" : "false"));
+            // log.info("body part exam tag: " + (bodyPartExam == null ? "NULL" : bodyPartExam));
+            // log.info("body part name: " + (bodyPartName == null ? "NULL" : bodyPartName));
+
+            // BodyPartExamined dicom tag is empty for whole body
+
+            // boolean include = (containsBodyPartKey && bodyPartExam == null && getDicomBodyPartName() == null) ? true
+            // :
+            // (getDicomBodyPartName() != null && getDicomBodyPartName().equals(bodyPartExam));
+
+            // if((containsBodyPartKey && bodyPartExam == null && bodyPartName == null) || (bodyPartName != null &&
+            // bodyPartName.equals(bodyPartExam))) {
+            // log.info("added dicom file to list of files");
+            // selectList.add(sdf);
+            // }
+          } catch(IOException e) {
+            throw new RuntimeException(e);
+          }
         }
-      }
 
-      if(scanID != null && pFileName != null) {
-        log.info("Retrieving P and R data from scan: " + scanID);
-        data.put(getResultPrefix() + "_SCANID", DataBuilder.buildText(scanID));
-        data.put(getResultPrefix() + "_SCAN_MODE", DataBuilder.buildText(scanMode));
-        data.put(getResultPrefix() + "_PFILE_NAME", DataBuilder.buildText(pFileName));
-        data.put(getResultPrefix() + "_RFILE_NAME", DataBuilder.buildText(rFileName));
+        if(!selectList.isEmpty()) {
 
-        File rFile = new File(scanDataDir, rFileName);
-        if(rFile.exists()) {
-          data.put(getResultPrefix() + "_RFILE", DataBuilder.buildBinary(rFile));
-        }
-      }
+          // Forearm
+          if("ARM".equals(getDicomBodyPartName()) && selectList.size() <= 2) {
+            data.put(getResultPrefix() + "_SCANID", DataBuilder.buildText(scanID));
+            data.put(getResultPrefix() + "_SCAN_MODE", DataBuilder.buildText(scanMode));
 
-      List<StoredDicomFile> selectList = new ArrayList<StoredDicomFile>();
-      List<StoredDicomFile> listDicomFiles = server.listSortedDicomFiles();
+            log.info("processing forearm dicom side: " + getSide().toString());
+            processFilesExtractionForeArm(getSide(), selectList, data);
+          }
+          // Lateral Spine
+          else if("LSPINE".equals(getDicomBodyPartName()) && selectList.size() == 3) {
+            data.put(getResultPrefix() + "_SCANID", DataBuilder.buildText(scanID));
+            data.put(getResultPrefix() + "_SCAN_MODE", DataBuilder.buildText(scanMode));
 
-      // TODO try refactor, it is a mess now
-      for(StoredDicomFile sdf : listDicomFiles) {
-        try {
-          DicomObject dicomObject = sdf.getDicomObject();
-          boolean containsBodyPartKey = dicomObject.contains(Tag.BodyPartExamined);
-          String bodyPartExam = dicomObject.getString(Tag.BodyPartExamined);
-          // if 2 null and scan contains Body Part Key we suppose that it is a whole body
-          boolean include = (containsBodyPartKey && bodyPartExam == null && getDicomBodyPartName() == null) ? true : (getDicomBodyPartName() != null && getDicomBodyPartName().equals(bodyPartExam));
-          if(include) selectList.add(sdf);
-        } catch(IOException e) {
-          throw new RuntimeException(e);
-        }
-      }
-      if(!selectList.isEmpty()) {
-        // Whole Body
-        if(getDicomBodyPartName() == null) {
-          processFilesExtractionWB(selectList, data);
-        }
-        // LSPINE and analysis
-        else if("LSPINE".equals(getDicomBodyPartName())) {
-          processFilesExtractionSpine(listDicomFiles, data);
-        }
-        // Other scan
-        else if("HIP".equals(getDicomBodyPartName())) {
-          processFilesExtractionHip(getSide(), selectList, data);
-        } else {
-          processFilesExtractionForeArm(getSide(), selectList, data);
+            log.info("processing spine dicom");
+            processFilesExtractionSpine(listDicomFiles, data);
+          }
+          // Hip
+          else if("HIP".equals(getDicomBodyPartName()) && selectList.size() <= 2) {
+            data.put(getResultPrefix() + "_SCANID", DataBuilder.buildText(scanID));
+            data.put(getResultPrefix() + "_SCAN_MODE", DataBuilder.buildText(scanMode));
+
+            log.info("processing hip dicom side: " + getSide().toString());
+            processFilesExtractionHip(getSide(), selectList, data);
+          }
+          // Whole Body
+          else if(null == getDicomBodyPartName() && selectList.size() == 2) {
+            data.put(getResultPrefix() + "_SCANID", DataBuilder.buildText(scanID));
+            data.put(getResultPrefix() + "_SCAN_MODE", DataBuilder.buildText(scanMode));
+
+            log.info("processing whole body dicom");
+            processFilesExtractionWB(selectList, data);
+          }
         }
       }
+
+      log.info("finished processing files");
       return data;
     }
+  }
 
-    private void processFilesExtractionHip(Side side, List<StoredDicomFile> files, Map<String, Data> data) {
-      try {
-        for(int i = 0; i < files.size(); i++) {
-          StoredDicomFile storedDicomFile = files.get(i);
-          if(side != null && (side == Side.LEFT ? "L" : "R").equals(storedDicomFile.getDicomObject().getString(Tag.Laterality))) {
-            putDicom(data, getResultPrefix() + "_DICOM", storedDicomFile);
-          }
+  /**
+   * Called by ScanAnalysisResultSetExtractor extractData(). Adds Hip scan dicom files to data collection.
+   * 
+   * @param side
+   * @param files
+   * @param data
+   */
+  private void processFilesExtractionHip(Side side, List<StoredDicomFile> files, Map<String, Data> data) {
+    try {
+      for(int i = 0; i < files.size(); i++) {
+        StoredDicomFile storedDicomFile = files.get(i);
+        if(side != null && (side == Side.LEFT ? "L" : "R").equals(storedDicomFile.getDicomObject().getString(Tag.Laterality))) {
+          putDicom(data, getResultPrefix() + "_DICOM", storedDicomFile);
         }
-      } catch(IOException e) {
       }
+    } catch(IOException e) {
     }
   }
 
+  /**
+   * Called by ScanAnalysisResultSetExtractor extractData(). Adds Whole Body scan dicom files to data collection.
+   * 
+   * @param files
+   * @param data
+   */
   private void processFilesExtractionWB(List<StoredDicomFile> files, Map<String, Data> data) {
     for(int i = 0; i < files.size(); i++) {
       StoredDicomFile storedDicomFile = files.get(i);
@@ -213,6 +480,13 @@ public abstract class APEXScanDataExtractor {
     }
   }
 
+  /**
+   * Called by ScanAnalysisResultSetExtractor extractData(). Adds Forearm scan dicom files to data collection.
+   * 
+   * @param side
+   * @param files
+   * @param data
+   */
   private void processFilesExtractionForeArm(Side side, List<StoredDicomFile> files, Map<String, Data> data) {
     try {
       for(int i = 0; i < files.size(); i++) {
@@ -225,6 +499,12 @@ public abstract class APEXScanDataExtractor {
     }
   }
 
+  /**
+   * Called by ScanAnalysisResultSetExtractor extractData(). Adds Spine scan dicom files to data collection.
+   * 
+   * @param files
+   * @param data
+   */
   private void processFilesExtractionSpine(List<StoredDicomFile> files, Map<String, Data> data) {
     try {
       for(int i = 0; i < files.size(); i++) {
@@ -243,6 +523,14 @@ public abstract class APEXScanDataExtractor {
     }
   }
 
+  /**
+   * Called by processFilesExtraction* methods. Add a dicom file exported from Apex via DICOM send transfer to the data
+   * collection.
+   * 
+   * @param data
+   * @param name
+   * @param storedDicomFile
+   */
   public void putDicom(Map<String, Data> data, String name, StoredDicomFile storedDicomFile) {
     boolean completeDicom = isCompleteDicom(storedDicomFile);
     apexReceiver.missingRawInDicomFile(completeDicom);
@@ -251,7 +539,8 @@ public abstract class APEXScanDataExtractor {
   }
 
   /**
-   * Return true if Dicom contains P and R files, false otherwise
+   * Called by putDicom(). Return true if dicom contains raw P & R data, false otherwise.
+   * 
    * @return
    */
   private boolean isCompleteDicom(StoredDicomFile storedDicomFile) {
@@ -260,7 +549,7 @@ public abstract class APEXScanDataExtractor {
         DicomObject dicomObject = storedDicomFile.getDicomObject();
         if(dicomObject.contains(tag.getValue())) {
           if(dicomObject.containsValue(tag.getValue()) == false) {
-            log.info("Missing P and/or R files");
+            log.info("Missing P and/or R data in DICOM file: " + tag.name());
             return false;
           }
         }
@@ -269,6 +558,15 @@ public abstract class APEXScanDataExtractor {
     return true;
   }
 
+  /**
+   * Called by extractDataImpl(). Implementation is specific to child classes which define Apex PatScan db table names
+   * corresponding to the type of scan. Adds all analysis variables to data collection.
+   * 
+   * @param table
+   * @param data
+   * @param rsExtractor
+   * @return
+   */
   protected Map<String, Data> extractScanData(String table, Map<String, Data> data, ResultSetExtractor<Map<String, Data>> rsExtractor) {
     return getPatScanDb().query("select * from " + table + " where PATIENT_KEY = ? and SCANID = ?", new PreparedStatementSetter() {
       public void setValues(PreparedStatement ps) throws SQLException {
@@ -278,6 +576,10 @@ public abstract class APEXScanDataExtractor {
     }, rsExtractor);
   }
 
+  /**
+   * Used during extractDataImpl(). Implementation of ResultSetExtractor. Processes the query that recovers all scan
+   * analysis variables from Apex PatScan db.
+   */
   protected abstract class ResultSetDataExtractor implements ResultSetExtractor<Map<String, Data>> {
 
     protected Map<String, Data> data;
@@ -337,4 +639,96 @@ public abstract class APEXScanDataExtractor {
     protected abstract void putData() throws SQLException, DataAccessException;
   }
 
+  /**
+   * Called by computeTZScore().
+   * 
+   * @param s1
+   * @param s2
+   * @return
+   * @throws ParseException
+   */
+  public static Double computeYearsDifference(String s1, String s2) throws ParseException {
+    SimpleDateFormat df = new SimpleDateFormat("yyy-MM-dd HH:mm:ss");
+    Date d1 = df.parse(s1);
+    Date d2 = df.parse(s2);
+
+    Calendar c1 = Calendar.getInstance();
+    c1.setTime(d1);
+    Calendar c2 = Calendar.getInstance();
+    c2.setTime(d2);
+
+    Double diff = (c1.getTimeInMillis() - c2.getTimeInMillis()) / (1000. * 60. * 60. * 24. * 365.25);
+    if(diff < 0.) diff *= -1.;
+
+    return diff;
+  }
+
+  /**
+   * Helper class for computeTZScore().
+   */
+  public final class ageBracket {
+    public Double ageMin;
+
+    public Double ageMax;
+
+    public Double ageSpan;
+
+    public ageBracket() {
+      ageMin = Double.MIN_VALUE;
+      ageMax = Double.MAX_VALUE;
+      ageSpan = ageMax - ageMin;
+    }
+
+    public void compute(Double age, List<Double> ageTable) {
+      for(int i = 0; i < ageTable.size() - 1; i++) {
+        double min = ageTable.get(i);
+        double max = ageTable.get(i + 1);
+        if(age >= min && age <= max) {
+          ageMin = min;
+          ageMax = age == min ? min : max;
+        }
+      }
+      ageSpan = ageMax - ageMin;
+    }
+  }
+
+  //
+  // Set/Get methods
+  //
+  /*
+   * protected String getPFileName() { return pFileName; }
+   * 
+   * protected String getRFileName() { return rFileName; }
+   */
+  protected JdbcTemplate getPatScanDb() {
+    return patScanDb;
+  }
+
+  protected String getParticipantKey() {
+    return participantData.get("participantKey");
+  }
+
+  protected String getParticipantDOB() {
+    return participantData.get("participantDOB");
+  }
+
+  protected String getParticipantGender() {
+    return participantData.get("participantGender");
+  }
+
+  protected String getResultPrefix() {
+    return getName();
+  }
+
+  protected String getScanID() {
+    return scanID;
+  }
+
+  protected String getScanDate() {
+    return scanDate;
+  }
+  /*
+   * public List<String> getFileNames() { return fileNames != null ? fileNames : (fileNames = new ArrayList<String>());
+   * }
+   */
 }
diff --git a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APSpineScanDataExtractor.java b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APSpineScanDataExtractor.java
index 8803ba6..960b279 100644
--- a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APSpineScanDataExtractor.java
+++ b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/APSpineScanDataExtractor.java
@@ -9,7 +9,6 @@
  ******************************************************************************/
 package org.obiba.onyx.jade.instrument.holologic;
 
-import java.io.File;
 import java.sql.SQLException;
 import java.util.Map;
 
@@ -26,8 +25,8 @@ public class APSpineScanDataExtractor extends APEXScanDataExtractor {
    * @param participantKey
    * @param server
    */
-  protected APSpineScanDataExtractor(JdbcTemplate patScanDb, File scanDataDir, String participantKey, DicomServer server, ApexReceiver apexReceiver) {
-    super(patScanDb, scanDataDir, participantKey, server, apexReceiver);
+  protected APSpineScanDataExtractor(JdbcTemplate patScanDb, JdbcTemplate refCurveDb, Map<String, String> participantData, DicomServer server, ApexReceiver apexReceiver) {
+    super(patScanDb, refCurveDb, participantData, server, apexReceiver);
   }
 
   @Override
@@ -50,6 +49,16 @@ public class APSpineScanDataExtractor extends APEXScanDataExtractor {
     return 1l;
   }
 
+  @Override
+  public String getRefType() {
+    return "S";
+  }
+
+  @Override
+  public String getRefSource() {
+    return "NHANES";
+  }
+
   private final class SpineResultSetExtractor extends ResultSetDataExtractor {
 
     public SpineResultSetExtractor(Map<String, Data> data) {
diff --git a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/ForearmScanDataExtractor.java b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/ForearmScanDataExtractor.java
index ba25e30..c4f11d8 100644
--- a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/ForearmScanDataExtractor.java
+++ b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/ForearmScanDataExtractor.java
@@ -9,7 +9,6 @@
  ******************************************************************************/
 package org.obiba.onyx.jade.instrument.holologic;
 
-import java.io.File;
 import java.sql.SQLException;
 import java.util.Map;
 
@@ -24,8 +23,8 @@ public class ForearmScanDataExtractor extends APEXScanDataExtractor {
 
   private Side side;
 
-  public ForearmScanDataExtractor(JdbcTemplate patScanDb, File scanDataDir, String pFileName, Side side, DicomServer server, ApexReceiver apexReceiver) {
-    super(patScanDb, scanDataDir, pFileName, server, apexReceiver);
+  public ForearmScanDataExtractor(JdbcTemplate patScanDb, JdbcTemplate refCurveDb, Map<String, String> participantData, Side side, DicomServer server, ApexReceiver apexReceiver) {
+    super(patScanDb, refCurveDb, participantData, server, apexReceiver);
     this.side = side;
   }
 
@@ -55,6 +54,16 @@ public class ForearmScanDataExtractor extends APEXScanDataExtractor {
   }
 
   @Override
+  public String getRefType() {
+    return "R";
+  }
+
+  @Override
+  public String getRefSource() {
+    return "Hologic";
+  }
+
+  @Override
   protected void extractDataImpl(Map<String, Data> data) {
     data.put(getResultPrefix() + "_SIDE", DataBuilder.buildText(side.toString()));
     extractScanData("Forearm", data, new ForearmResultSetExtractor(data));
diff --git a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/HipScanDataExtractor.java b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/HipScanDataExtractor.java
index f829607..769b8a0 100644
--- a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/HipScanDataExtractor.java
+++ b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/HipScanDataExtractor.java
@@ -9,7 +9,6 @@
  ******************************************************************************/
 package org.obiba.onyx.jade.instrument.holologic;
 
-import java.io.File;
 import java.sql.SQLException;
 import java.util.Map;
 
@@ -32,8 +31,8 @@ public class HipScanDataExtractor extends APEXScanDataExtractor {
    * @param participantKey
    * @param server
    */
-  protected HipScanDataExtractor(JdbcTemplate patScanDb, File scanDataDir, String participantKey, Side side, DicomServer server, ApexReceiver apexReceiver) {
-    super(patScanDb, scanDataDir, participantKey, server, apexReceiver);
+  protected HipScanDataExtractor(JdbcTemplate patScanDb, JdbcTemplate refCurveDb, Map<String, String> participantData, Side side, DicomServer server, ApexReceiver apexReceiver) {
+    super(patScanDb, refCurveDb, participantData, server, apexReceiver);
     this.side = side;
   }
 
@@ -69,6 +68,16 @@ public class HipScanDataExtractor extends APEXScanDataExtractor {
     }
   }
 
+  @Override
+  public String getRefType() {
+    return "H";
+  }
+
+  @Override
+  public String getRefSource() {
+    return "NHANES";
+  }
+
   private final class HipResultSetExtractor extends ResultSetDataExtractor {
 
     public HipResultSetExtractor(Map<String, Data> data) {
diff --git a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/IVAImagingScanDataExtractor.java b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/IVAImagingScanDataExtractor.java
index 6e25e7e..74eac77 100644
--- a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/IVAImagingScanDataExtractor.java
+++ b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/IVAImagingScanDataExtractor.java
@@ -9,7 +9,6 @@
  ******************************************************************************/
 package org.obiba.onyx.jade.instrument.holologic;
 
-import java.io.File;
 import java.util.Map;
 
 import org.dcm4che2.tool.dcmrcv.DicomServer;
@@ -25,8 +24,8 @@ public class IVAImagingScanDataExtractor extends APEXScanDataExtractor {
 
   private Energy energy;
 
-  protected IVAImagingScanDataExtractor(JdbcTemplate patScanDb, File scanDataDir, String participantKey, Energy energy, DicomServer server, ApexReceiver apexReceiver) {
-    super(patScanDb, scanDataDir, participantKey, server, apexReceiver);
+  protected IVAImagingScanDataExtractor(JdbcTemplate patScanDb, JdbcTemplate refCurveDb, Map<String, String> participantData, Energy energy, DicomServer server, ApexReceiver apexReceiver) {
+    super(patScanDb, refCurveDb, participantData, server, apexReceiver);
     this.energy = energy;
   }
 
@@ -49,17 +48,32 @@ public class IVAImagingScanDataExtractor extends APEXScanDataExtractor {
   protected long getScanType() {
     switch(energy) {
     case CLSA_DXA:
-      return 29l;
+      return 29l; // QDR4500 single energy supine lateral image, used for VFA, ref_type = L
     case SINGLE_AP:
-      return 35l;
+      return 35l; // single energy AP image, ref_type = S
     case SINGLE_LATERAL:
-      return 36l;
+      return 36l; // single energy left/right lateral image, ref_type = L
     default:
-      return 37l;
+      return 37l; // dual energy left/right lateral image, ref_type = L
     }
   }
 
   @Override
+  public String getRefType() {
+    switch(energy) {
+    case SINGLE_AP:
+      return "S"; // single energy AP image, ref_type = S
+    default:
+      return "L"; // dual energy left/right lateral image, ref_type = L
+    }
+  }
+
+  @Override
+  public String getRefSource() {
+    return "NHANES";
+  }
+
+  @Override
   protected void extractDataImpl(Map<String, Data> data) {
     log.warn("no additional data can be extracted for this scan");
   }
diff --git a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/WholeBodyScanDataExtractor.java b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/WholeBodyScanDataExtractor.java
index 0373237..5dd439a 100644
--- a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/WholeBodyScanDataExtractor.java
+++ b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/java/org/obiba/onyx/jade/instrument/holologic/WholeBodyScanDataExtractor.java
@@ -9,7 +9,6 @@
  ******************************************************************************/
 package org.obiba.onyx.jade.instrument.holologic;
 
-import java.io.File;
 import java.sql.SQLException;
 import java.util.Map;
 
@@ -24,8 +23,8 @@ import org.springframework.jdbc.core.JdbcTemplate;
  */
 public class WholeBodyScanDataExtractor extends APEXScanDataExtractor {
 
-  protected WholeBodyScanDataExtractor(JdbcTemplate patScanDb, File scanDataDir, String participantKey, DicomServer server, ApexReceiver apexReceiver) {
-    super(patScanDb, scanDataDir, participantKey, server, apexReceiver);
+  protected WholeBodyScanDataExtractor(JdbcTemplate patScanDb, JdbcTemplate refCurveDb, Map<String, String> participantData, DicomServer server, ApexReceiver apexReceiver) {
+    super(patScanDb, refCurveDb, participantData, server, apexReceiver);
   }
 
   @Override
@@ -44,6 +43,16 @@ public class WholeBodyScanDataExtractor extends APEXScanDataExtractor {
   }
 
   @Override
+  public String getRefType() {
+    return "W";
+  }
+
+  @Override
+  public String getRefSource() {
+    return "NHANES";
+  }
+
+  @Override
   protected void extractDataImpl(Map<String, Data> data) {
     extractScanData("Wbody", data, new WbodyResultSetExtractor(data));
     extractScanData("WbodyComposition", data, new WbodyCompositionResultSetExtractor(data));
diff --git a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/resources/META-INF/onyx/defaults.properties b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/resources/META-INF/onyx/defaults.properties
index 0ac062a..60761c4 100644
--- a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/resources/META-INF/onyx/defaults.properties
+++ b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/resources/META-INF/onyx/defaults.properties
@@ -7,13 +7,17 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #-------------------------------------------------------------------------------
-org.obiba.onyx.jade.instrument.holologic.apex.driver=sun.jdbc.odbc.JdbcOdbcDriver
-org.obiba.onyx.jade.instrument.holologic.apex.url=jdbc:odbc:DRIVER=Microsoft Access Driver (*.mdb);DBQ=C:/QDR/Data/PatScan.mdb;DriverId=25;FIL=MSAccess
-org.obiba.onyx.jade.instrument.holologic.apex.username=
-org.obiba.onyx.jade.instrument.holologic.apex.password=
+org.obiba.onyx.jade.instrument.holologic.apex.patscan.driver=sun.jdbc.odbc.JdbcOdbcDriver
+org.obiba.onyx.jade.instrument.holologic.apex.patscan.url=jdbc:odbc:DRIVER=Microsoft Access Driver (*.mdb);DBQ=C:/QDR/Data/PatScan.mdb;DriverId=25;FIL=MSAccess
+org.obiba.onyx.jade.instrument.holologic.apex.patscan.username=
+org.obiba.onyx.jade.instrument.holologic.apex.patscan.password=
+
+org.obiba.onyx.jade.instrument.holologic.apex.refcurve.driver=sun.jdbc.odbc.JdbcOdbcDriver
+org.obiba.onyx.jade.instrument.holologic.apex.refcurve.url=jdbc:odbc:DRIVER=Microsoft Access Driver (*.mdb);DBQ=C:/QDR/Data/Reference.mdb;DriverId=25;FIL=MSAccess
+org.obiba.onyx.jade.instrument.holologic.apex.refcurve.username=
+org.obiba.onyx.jade.instrument.holologic.apex.refcurve.password=
 
 org.obiba.onyx.jade.instrument.holologic.apex.dicom.aeTitle=ONYXDICOM
 org.obiba.onyx.jade.instrument.holologic.apex.dicom.hostname=localhost
 org.obiba.onyx.jade.instrument.holologic.apex.dicom.port=8900
 org.obiba.onyx.jade.instrument.holologic.apex.dicom.stgCmtPort=104
-
diff --git a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/resources/META-INF/spring/instrument-context.xml b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/resources/META-INF/spring/instrument-context.xml
index b045d9d..089c085 100644
--- a/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/resources/META-INF/spring/instrument-context.xml
+++ b/onyx-modules/jade/instrument-parent/interface-bonedensity-holologic-apex/src/main/resources/META-INF/spring/instrument-context.xml
@@ -13,6 +13,7 @@
   <bean name="instrumentRunner" class="org.obiba.onyx.jade.instrument.holologic.APEXInstrumentRunner">
     <property name="instrumentExecutionService" ref="instrumentExecutionService" />
     <property name="patScanDb" ref="patScanDb" />
+    <property name="refCurveDb" ref="refCurveDb" />
     <property name="dicomSettings">
       <bean class="org.obiba.onyx.jade.instrument.holologic.DicomSettings">
         <property name="aeTitle" value="${org.obiba.onyx.jade.instrument.holologic.apex.dicom.aeTitle}" />
@@ -25,14 +26,25 @@
   </bean>
 
   <bean id="patScanDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
-    <property name="driverClassName" value="${org.obiba.onyx.jade.instrument.holologic.apex.driver}" />
-    <property name="url" value="${org.obiba.onyx.jade.instrument.holologic.apex.url}" />
-    <property name="username" value="${org.obiba.onyx.jade.instrument.holologic.apex.username}" />
-    <property name="password" value="${org.obiba.onyx.jade.instrument.holologic.apex.password}" />
+    <property name="driverClassName" value="${org.obiba.onyx.jade.instrument.holologic.apex.patscan.driver}" />
+    <property name="url" value="${org.obiba.onyx.jade.instrument.holologic.apex.patscan.url}" />
+    <property name="username" value="${org.obiba.onyx.jade.instrument.holologic.apex.patscan.username}" />
+    <property name="password" value="${org.obiba.onyx.jade.instrument.holologic.apex.patscan.password}" />
   </bean>
 
   <bean name="patScanDb" class="org.springframework.jdbc.core.JdbcTemplate">
     <property name="dataSource" ref="patScanDataSource" />
   </bean>
+  
+  <bean id="refCurveDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
+    <property name="driverClassName" value="${org.obiba.onyx.jade.instrument.holologic.apex.refcurve.driver}"/>
+    <property name="url" value="${org.obiba.onyx.jade.instrument.holologic.apex.refcurve.url}"/>
+    <property name="username" value="${org.obiba.onyx.jade.instrument.holologic.apex.refcurve.username}"/>
+    <property name="password" value="${org.obiba.onyx.jade.instrument.holologic.apex.refcurve.password}"/>
+  </bean>
+  
+  <bean name="refCurveDb" class="org.springframework.jdbc.core.JdbcTemplate">
+    <property name="dataSource" ref="refCurveDataSource" />
+  </bean> 
 
 </beans>
-- 
1.7.9.5

